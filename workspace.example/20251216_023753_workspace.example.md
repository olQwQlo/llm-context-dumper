===== BEGIN FILE: DUMP_META =====
file_tree=FILE_TREE
file_block=BEGIN/END
begin_pattern="===== BEGIN FILE: {path} | lang={lang} ====="
end_pattern="===== END FILE: {path} ====="
redaction_notice="Files may be omitted or redacted; see inline placeholders."
===== END FILE: DUMP_META =====

===== BEGIN FILE: FILE_TREE =====
workspace.example
├─ 20251216_023753_This Repository.md
├─ BatchDump.ps1
└─ workspace.json
===== END FILE: FILE_TREE =====

===== BEGIN FILE: 20251216_023753_This Repository.md | lang=markdown =====
===== BEGIN FILE: DUMP_META =====
file_tree=FILE_TREE
file_block=BEGIN/END
begin_pattern="===== BEGIN FILE: {path} | lang={lang} ====="
end_pattern="===== END FILE: {path} ====="
redaction_notice="Files may be omitted or redacted; see inline placeholders."
===== END FILE: DUMP_META =====

===== BEGIN FILE: FILE_TREE =====
llm-context-dumper
├─ .git/ [DIR:本文非表示]
├─ workspace/ [DIR:本文非表示]
├─ workspace.example/
│  ├─ BatchDump.ps1
│  └─ workspace.json
├─ .gitignore
├─ LICENSE
├─ README.md
├─ RepoDump.json [FILE:本文非表示]
├─ RepoDump.json.example
└─ RepoDump.ps1
===== END FILE: FILE_TREE =====

===== BEGIN FILE: .gitignore | lang=text =====
RepoDump.json
# Output file
dump.md

workspace/
===== END FILE: .gitignore =====

===== BEGIN FILE: LICENSE | lang=text =====
MIT License

Copyright (c) 2025 olOwOlo

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
===== END FILE: LICENSE =====

===== BEGIN FILE: README.md | lang=markdown =====
# repo-to-markdown-ps 📄➡️📦

A high-performance PowerShell script that converts an entire project directory into a single **LLM-optimized context archive**.
Designed to create **context for LLMs** (ChatGPT, Claude, Gemini, etc.).

## ✨ Features

- **🌲 Visual File Tree**: Generates a clear directory structure at the top.
- **🚫 Smart Filtering**:
  - Respects `.gitignore` (optional).
  - Automatically hides `node_modules`, `.git`, binaries, and build artifacts.
  - **Security Redaction**: Hides contents of secrets (`.env`, private keys) while keeping the file structure.
- **🚀 High Performance**: Supports parallel reading (`-ParallelRead`) for large repositories using PowerShell 7+.
- **🤖 LLM-Optimized Sentinel Output**: Uses explicit `BEGIN/END` markers for zero-ambiguity parsing by AI models, removing standard Markdown formatting to maximize reliability.

## 📄 Output Format

The output uses a specific **Sentinel Protocol** designed for LLMs, avoiding Markdown rendering ambiguity.

```text
===== BEGIN FILE: DUMP_META =====
format=repodump-v2
...
===== END FILE: DUMP_META =====

===== BEGIN FILE: FILE_TREE =====
my-project
├─ src/
│  └─ main.rs
└─ README.md
===== END FILE: FILE_TREE =====

===== BEGIN FILE: src/main.rs | lang=rust =====
fn main() {
    println!("Hello, world!");
}
===== END FILE: src/main.rs =====
```

## 🚀 Usage

Download `RepoDump.ps1` and run it in your terminal.

### Setup (Optional)

To customize exclusion rules and redaction patterns, copy `RepoDump.json.example` to `RepoDump.json`:

```powershell
Copy-Item RepoDump.json.example RepoDump.json
```

### Basic Usage

```powershell
./RepoDump.ps1 -RootPath "C:\Projects\MyApp"
```

This generates `dump.md` in the current directory.

### Advanced Usage

```powershell
./RepoDump.ps1 `
  -RootPath "C:\Projects\MyApp" `
  -OutPath "./context.md" `
  -UseGitignore `
  -ParallelRead `
  -ShowProgress
```

## 📦 Batch Dump Tool

For managing multiple context dumps (e.g., separating "Whole Project", "Backend", "Frontend"), use the batch tool provided in the `workspace.example` directory.

### Setup

1. Copy the example workspace to create your own working environment:
   ```powershell
   Copy-Item -Recurse workspace.example workspace
   ```
   The `workspace` directory is ignored by git, providing a clean sandbox for your dumps.

2. Edit `workspace/workspace.json` to define your targets. Paths are relative to the project root.
   ```json
   {
     "Targets": [
       { "Name": "WholeProject", "Path": "." },
       { "Name": "Backend", "Path": "backend" }
     ]
   }
   ```

### Usage

```powershell
cd workspace
./BatchDump.ps1
```

This will generate timestamped markdown files (e.g., `20251216_120000_WholeProject.md`) inside the `workspace` directory.

## ⚙️ Parameters

| Parameter | Description | Default |
| :--- | :--- | :--- |
| `-RootPath` | Target directory path (Required). | - |
| `-OutPath` | Output file path. | `./dump.md` |
| `-UseGitignore` | Use `.gitignore` to exclude files. | `false` |
| `-ParallelRead` | Enable parallel processing (Requires PS 7+). | `false` |
| `-ThrottleLimit` | Concurrency limit for parallel reading. | `4` |
| `-ShowProgress` | Show progress bar during processing. | `false` |
| `-CsvPreviewLines` | Number of lines to preview for CSV files. | `5` |
| `-ConfigFile` | Path to a custom configuration JSON file. | `RepoDump.json` |
| `-MaxFileSizeMB` | Skip files larger than this size. | `5` (MB) |

## 🛡️ Security Note

This script attempts to redact sensitive files (like `.env`, `id_rsa`, `*.pem`) by default. However, **always review the output file** before uploading it to any third-party AI service to ensure no secrets are leaked.

## 📄 License

MIT License
===== END FILE: README.md =====

===== BEGIN FILE: RepoDump.json | lang=redacted =====
[REDACTED: Hidden file (build artifact, binary, etc.)]
===== END FILE: RepoDump.json =====

===== BEGIN FILE: RepoDump.json.example | lang=text =====
{
  "HideDirNames": [
    ".git",
    ".svn",
    ".hg",
    "node_modules",
    "bower_components",
    "vendor",
    "dist",
    "build",
    "out",
    ".next",
    ".nuxt",
    ".svelte-kit",
    ".turbo",
    ".cache",
    ".parcel-cache",
    "coverage",
    ".nyc_output",
    "bin",
    "obj",
    "target",
    ".venv",
    "venv",
    "__pycache__",
    ".pytest_cache",
    ".mypy_cache",
    ".ruff_cache",
    ".gradle",
    ".idea",
    ".vscode",
    ".terraform",
    ".terragrunt-cache"
  ],
  "HideFilePatterns": [
    "*.exe",
    "*.dll",
    "*.so",
    "*.dylib",
    "*.a",
    "*.lib",
    "*.pdb",
    "*.obj",
    "*.o",
    "*.class",
    "*.jar",
    "*.war",
    "*.png",
    "*.jpg",
    "*.jpeg",
    "*.gif",
    "*.webp",
    "*.ico",
    "*.svg",
    "*.mp4",
    "*.mov",
    "*.mkv",
    "*.avi",
    "*.mp3",
    "*.wav",
    "*.flac",
    "*.zip",
    "*.7z",
    "*.rar",
    "*.tar",
    "*.gz",
    "*.bz2",
    "*.xz",
    "*.pdf",
    "*.doc",
    "*.docx",
    "*.ppt",
    "*.pptx",
    "*.xls",
    "*.xlsx",
    "*.ttf",
    "*.otf",
    "*.woff",
    "*.woff2",
    "*.db",
    "*.sqlite",
    "*.sqlite3",
    "*.log",
    "package-lock.json",
    "yarn.lock",
    "pnpm-lock.yaml"
  ],
  "RedactFilePatterns": [
    ".env",
    "*.env",
    ".env.*",
    "*.pem",
    "*.key",
    "*.pfx",
    "*.p12",
    "*.kdbx",
    "id_rsa",
    "id_ed25519",
    "known_hosts",
    ".npmrc",
    ".pypirc",
    ".dockerconfigjson"
  ],
  "RedactDirNames": [
    ".aws",
    ".ssh",
    ".gnupg"
  ],
  "AllowEnvNames": [
    ".env.sample",
    ".env.example",
    ".env.template"
  ]
}
===== END FILE: RepoDump.json.example =====

===== BEGIN FILE: RepoDump.ps1 | lang=powershell =====
param(
  [Parameter(Mandatory = $true, Position = 0)]
  [string]$RootPath,

  [string]$OutPath,

  # ========== “ディレクトリごと” 本文を非表示（ツリーには残す） ==========
  [string[]]$HideDirNames = @(
    ".git", ".svn", ".hg",
    "node_modules", "bower_components", "vendor",
    "dist", "build", "out", ".next", ".nuxt", ".svelte-kit",
    ".turbo", ".cache", ".parcel-cache",
    "coverage", ".nyc_output",
    "bin", "obj", "target",
    ".venv", "venv", "__pycache__", ".pytest_cache", ".mypy_cache", ".ruff_cache",
    ".gradle", ".idea", ".vscode",
    ".terraform", ".terragrunt-cache"
  ),

  # ========== “ファイル単体” 本文を非表示（ツリーには残す） ==========
  [string[]]$HideFilePatterns = @(
    "*.exe", "*.dll", "*.so", "*.dylib", "*.a", "*.lib",
    "*.pdb", "*.obj", "*.o", "*.class", "*.jar", "*.war",
    "*.png", "*.jpg", "*.jpeg", "*.gif", "*.webp", "*.ico", "*.svg",
    "*.mp4", "*.mov", "*.mkv", "*.avi", "*.mp3", "*.wav", "*.flac",
    "*.zip", "*.7z", "*.rar", "*.tar", "*.gz", "*.bz2", "*.xz",
    "*.pdf", "*.doc", "*.docx", "*.ppt", "*.pptx", "*.xls", "*.xlsx",
    "*.ttf", "*.otf", "*.woff", "*.woff2",
    "*.db", "*.sqlite", "*.sqlite3",
    "*.log",
    "package-lock.json", "yarn.lock", "pnpm-lock.yaml"
  ),

  # ========== 機微情報: “存在は示すが本文は伏せる” ==========
  [string[]]$RedactFilePatterns = @(
    ".env", "*.env", ".env.*",
    "*.pem", "*.key", "*.pfx", "*.p12", "*.kdbx",
    "id_rsa", "id_ed25519", "known_hosts",
    ".npmrc", ".pypirc", ".dockerconfigjson"
  ),
  [string[]]$RedactDirNames = @(".aws", ".ssh", ".gnupg"),

  # envでも中身を出してよい例外
  [string[]]$AllowEnvNames = @(".env.sample", ".env.example", ".env.template"),

  # 念のため（巨大ファイル・バイナリ）
  [int]$MaxFileSizeMB = 5,

  # ========== 改善: .gitignore 簡易取り込み ==========
  [switch]$UseGitignore,

  # ========== 改善: 進捗表示 ==========
  [switch]$ShowProgress,

  # ========== 改善: CSVプレビュー行数 ==========
  [int]$CsvPreviewLines = 5,

  # ========== 設定ファイル（任意） ==========
  # 指定がなければスクリプト同階層の RepoDump.json を探す
  [string]$ConfigFile,

  # ========== 改善: PS7 での並列読み込み（順序は維持） ==========
  [switch]$ParallelRead,
  [int]$ThrottleLimit = 4,

  # ========== 改善: 自己除外制御 ==========
  [switch]$ExcludeSelf
)


if (-not $OutPath) {
  $base = $(if ($PSScriptRoot) { $PSScriptRoot } else { (Get-Location).Path })
  $OutPath = Join-Path -Path $base -ChildPath "dump.md"
}

Write-Host "[DEBUG] Script started. RootPath: $RootPath"
Write-Host "[DEBUG] OutPath: $OutPath"

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# ---------------------------
# 設定ファイル読み込み（上書き）
# ---------------------------
$baseConfig = $(if ($PSScriptRoot) { $PSScriptRoot } else { (Get-Location).Path })
$configPath = if ($ConfigFile) { $ConfigFile } else { Join-Path $baseConfig "RepoDump.json" }
if (Test-Path -LiteralPath $configPath) {
  try {
    $cfg = Get-Content -LiteralPath $configPath -Raw -Encoding UTF8 | ConvertFrom-Json
    if ($cfg.HideDirNames) { $HideDirNames = @($cfg.HideDirNames) }
    if ($cfg.HideFilePatterns) { $HideFilePatterns = @($cfg.HideFilePatterns) }
    if ($cfg.RedactDirNames) { $RedactDirNames = @($cfg.RedactDirNames) }
    if ($cfg.RedactFilePatterns) { $RedactFilePatterns = @($cfg.RedactFilePatterns) }
    if ($cfg.AllowEnvNames) { $AllowEnvNames = @($cfg.AllowEnvNames) }
    Write-Host "[INFO] Loaded configuration from: $configPath"
  }
  catch {
    Write-Warning "Failed to load configuration from $configPath : $_"
  }
}

# ---------------------------
# 定数（マジックナンバー排除）
# ---------------------------
$script:BinaryDetectionBufferSize = 4096

# ---------------------------
# 小物ユーティリティ
# ---------------------------
function Resolve-FullPath([string]$p) { (Resolve-Path -LiteralPath $p).Path }

function Get-RelativePath([string]$root, [string]$fullPath) {
  if ($fullPath.StartsWith($root)) {
    return $fullPath.Substring($root.Length).TrimStart('\', '/')
  }
  return $fullPath
}

function Get-NormalizedPath([string]$rel) { $rel.Replace("\", "/") }

function Test-NameIn([string]$name, [string[]]$names) {
  foreach ($n in $names) { if ($name -ieq $n) { return $true } }
  return $false
}

function Test-MatchAnyPattern([string]$name, [string[]]$patterns) {
  foreach ($pat in $patterns) { if ($name -like $pat) { return $true } }
  return $false
}

# レビュー案に沿って統合：ディレクトリ名＋ファイル名パターンをまとめて判定
function Test-PathMatchesPattern(
  [string]$relPath,
  [string[]]$dirNames,
  [string[]]$filePatterns
) {
  $parts = @($relPath -split "[\\/]")
  if ($parts.Count -gt 1) {
    for ($i = 0; $i -lt $parts.Count - 1; $i++) {
      if (Test-NameIn $parts[$i] $dirNames) { return $true }
    }
  }
  $leaf = $parts[-1]
  if (Test-MatchAnyPattern $leaf $filePatterns) { return $true }
  return $false
}


function Get-HiddenAncestorRel([string]$relPath, [string[]]$hideDirNames, [bool]$isDirectory = $false) {
  $parts = @($relPath -split "[\\/]" | Where-Object { $_ -ne "" })
  if ($parts.Count -eq 0) { return $null }

  $limit = $(if ($isDirectory) { $parts.Count } elseif ($parts.Count -gt 1) { $parts.Count - 1 } else { 0 })
  if ($limit -le 0) { return $null }

  $accum = New-Object System.Collections.Generic.List[string]
  for ($i = 0; $i -lt $limit; $i++) {
    $name = $parts[$i]
    if (Test-NameIn $name $hideDirNames) {
      $accum.Add($name) | Out-Null
      return ($accum -join "/")
    }
    $accum.Add($name) | Out-Null
  }

  return $null
}

function Find-SensitiveContent([string]$text) {
  $hits = New-Object System.Collections.Generic.List[string]

  if ($text -match "ghp_[A-Za-z0-9]{24,}") { $hits.Add("GitHub token") | Out-Null }
  if ($text -match "github_pat_[A-Za-z0-9_]{20,}") { $hits.Add("GitHub PAT") | Out-Null }
  if ($text -match "AKIA[0-9A-Z]{16}") { $hits.Add("AWS Access Key") | Out-Null }
  if ($text -match "-----BEGIN (?:RSA|OPENSSH|EC) PRIVATE KEY-----") { $hits.Add("Private key block") | Out-Null }
  if ($text -match "\b[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}\.[A-Za-z0-9_-]{20,}\b") { $hits.Add("JWT-like token") | Out-Null }

  return $hits.ToArray()
}

function Get-LangFromExtension([string]$ext) {
  switch ($ext.ToLowerInvariant()) {
    ".ps1" { "powershell" } ".psm1" { "powershell" } ".psd1" { "powershell" }
    ".js" { "javascript" } ".ts" { "typescript" } ".tsx" { "tsx" } ".jsx" { "jsx" }
    ".py" { "python" } ".rb" { "ruby" } ".go" { "go" } ".rs" { "rust" }
    ".java" { "java" } ".cs" { "csharp" } ".cpp" { "cpp" } ".c" { "c" } ".h" { "c" } ".hpp" { "cpp" }
    ".json" { "json" } ".yml" { "yaml" } ".yaml" { "yaml" } ".xml" { "xml" }
    ".md" { "markdown" } ".html" { "html" } ".css" { "css" } ".sql" { "sql" }
    default { "" }
  }
}

function Test-IsProbablyBinary([string]$filePath) {
  # “意図”: 先頭数KBにNULLバイトが混ざるならバイナリ扱い（高速で雑に強い）
  # 修正: UTF-16/32 BOMがある場合はテキストとみなす
  $fs = [System.IO.File]::Open($filePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite)
  try {
    $buf = New-Object byte[] $script:BinaryDetectionBufferSize
    $read = $fs.Read($buf, 0, $buf.Length)

    # BOM Check
    if ($read -ge 2) {
      # UTF-16 LE/BE
      if (($buf[0] -eq 0xFF -and $buf[1] -eq 0xFE) -or ($buf[0] -eq 0xFE -and $buf[1] -eq 0xFF)) { return $false }
    }
    if ($read -ge 4) {
      # UTF-32 LE/BE
      if (($buf[0] -eq 0x00 -and $buf[1] -eq 0x00 -and $buf[2] -eq 0xFE -and $buf[3] -eq 0xFF) -or
        ($buf[0] -eq 0xFF -and $buf[1] -eq 0xFE -and $buf[2] -eq 0x00 -and $buf[3] -eq 0x00)) { return $false }
    }

    for ($i = 0; $i -lt $read; $i++) { if ($buf[$i] -eq 0) { return $true } }
    return $false
  }
  finally { $fs.Dispose() }
}

function Read-TextFileAutoEncoding([string]$filePath, [int]$LimitLines = 0) {
  # “意図”: BOMがあれば尊重、なければUTF-8優先で読む（不明は置換で落とさない）
  $fs = [System.IO.File]::Open($filePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite)
  try {
    $reader = New-Object System.IO.StreamReader($fs, [System.Text.Encoding]::UTF8, $true, 4096, $true)
    
    if ($LimitLines -gt 0) {
      $max = $LimitLines
      $acc = New-Object System.Collections.Generic.List[string]
      while ($max -gt 0 -and -not $reader.EndOfStream) {
        $line = $reader.ReadLine()
        if ($null -eq $line) { break }
        $acc.Add($line) | Out-Null
        $max--
      }
      if (-not $reader.EndOfStream) {
        $acc.Add("... (truncated first $LimitLines lines)") | Out-Null
      }
      $reader.Dispose()
      return ($acc -join [Environment]::NewLine)
    }

    $text = $reader.ReadToEnd()
    $reader.Dispose()
    return $text
  }
  finally { $fs.Dispose() }
}

# ---------------------------
# .gitignore（簡易）取り込み
# ---------------------------
function Convert-GitignoreToLikePatterns([string]$rootFull) {
  $gi = Join-Path $rootFull ".gitignore"
  if (-not (Test-Path -LiteralPath $gi)) { return [pscustomobject]@{ DirNames = @(); FilePatterns = @() } }

  $dirNames = New-Object System.Collections.Generic.List[string]
  $filePats = New-Object System.Collections.Generic.List[string]

  $lines = Get-Content -LiteralPath $gi -ErrorAction Stop
  foreach ($raw in $lines) {
    $line = $raw.Trim()
    if (-not $line) { continue }
    if ($line.StartsWith("#")) { continue }
    if ($line.StartsWith("!")) { continue } # 簡易版では否定は無視

    # 末尾 / はディレクトリ扱い（名前だけ拾う）
    if ($line.EndsWith("/")) {
      $name = ($line.TrimEnd("/") -split "[/\\]")[-1]
      if ($name) { $dirNames.Add($name) | Out-Null }
      continue
    }

    # それ以外は “拡張子系だけ拾う” に割り切る（過剰除外を避ける）
    if ($line -match "[/\\]") { continue } # 階層指定は捨てる

    if ($line -notmatch "\.") { continue } # 拡張子を含まないものはスキップ

    $pat = $line
    if (-not $pat.StartsWith("*")) { $pat = "*$pat" }
    $filePats.Add($pat) | Out-Null
  }

  return [pscustomobject]@{
    DirNames     = $dirNames.ToArray()
    FilePatterns = $filePats.ToArray()
  }
}

# ---------------------------
# メインロジック
# ---------------------------
$rootFull = Resolve-FullPath $RootPath
$maxBytes = $MaxFileSizeMB * 1MB

# .gitignore取り込み（任意）
$gi = Convert-GitignoreToLikePatterns $rootFull
if ($UseGitignore) {
  $HideDirNames = @($HideDirNames + $gi.DirNames)
  $HideFilePatterns = @($HideFilePatterns + $gi.FilePatterns)
}

# “伏せたディレクトリ” を Files セクションで 1回だけ説明するための集合
function Get-TreeLines([string]$rootFull, [hashtable]$DetectedSecrets) {
  $lines = New-Object System.Collections.Generic.List[string]
  $lines.Add("===== BEGIN FILE: FILE_TREE =====")
  $lines.Add((Split-Path -Leaf $rootFull))

  function Walk([string]$dir, [string]$prefix, [string]$relFromRoot) {
    $children = @(Get-ChildItem -LiteralPath $dir -Force | Sort-Object @{Expression = "PSIsContainer"; Descending = $true }, Name)

    for ($i = 0; $i -lt $children.Count; $i++) {
      $item = $children[$i]
      $isLast = ($i -eq $children.Count - 1)
      $branch = $(if ($isLast) { "└─ " } else { "├─ " })
      $nextPrefix = $prefix + $(if ($isLast) { "   " } else { "│  " })

      if ($item.PSIsContainer) {
        $childRel = $(if ([string]::IsNullOrEmpty($relFromRoot)) { $item.Name } else { "$relFromRoot/$($item.Name)" })


        if (Test-NameIn $item.Name $HideDirNames) {
          $lines.Add("$prefix$branch$($item.Name)/ [DIR:本文非表示]")
          continue
        }

        # 機微ディレクトリなら中身を見せずに停止
        if (Test-NameIn $item.Name $RedactDirNames) {
          $lines.Add("$prefix$branch$($item.Name)/ [機微:本文非表示]")
          continue
        }

        $lines.Add("$prefix$branch$($item.Name)/")
        Walk $item.FullName $nextPrefix $childRel
      }
      else {
        $leafRel = $(if ([string]::IsNullOrEmpty($relFromRoot)) { $item.Name } else { "$relFromRoot/$($item.Name)" })
        $tag = ""

        if (Test-MatchAnyPattern $item.Name $HideFilePatterns) { $tag = " [FILE:本文非表示]" }
        elseif (Test-PathMatchesPattern $leafRel $RedactDirNames $RedactFilePatterns -and -not (Test-NameIn $item.Name $AllowEnvNames)) { $tag = " [機微:本文非表示]" }
        elseif ($DetectedSecrets.ContainsKey($leafRel)) {
          $tag = " [機微:本文非表示:検出項目 " + ($DetectedSecrets[$leafRel] -join ", ") + "]"
        }

        $lines.Add("$prefix$branch$($item.Name)$tag")
      }
    }
  }

  Walk $rootFull "" ""
  $lines.Add("===== END FILE: FILE_TREE =====")
  $lines.Add("")
  return $lines
}

# 早期フィルタ：-File を使ってまず “ファイルだけ” 列挙（大規模で効く）
# Access Denied回避のために ErrorAction SilentlyContinue
$allFiles = @(
  Get-ChildItem -LiteralPath $rootFull -Recurse -Force -File -ErrorAction SilentlyContinue |
  Sort-Object @{Expression = { $_.DirectoryName }; Ascending = $true }, @{Expression = { $_.Name }; Ascending = $true }
)

# 自己参照（このスクリプト自身）の除外はオプション
if ($ExcludeSelf -and $PSCommandPath) {
  $allFiles = @($allFiles | Where-Object { $_.FullName -ne $PSCommandPath })
}
# 出力先ファイルが含まれていたら除外（無限ループ/肥大化防止）
if ($OutPath) {
  $outFull = [System.IO.Path]::GetFullPath($OutPath)
  $allFiles = @($allFiles | Where-Object { $_.FullName -ne $outFull })
}
Write-Host "[DEBUG] Found $($allFiles.Count) files to process."

$writtenHiddenDir = New-Object "System.Collections.Generic.HashSet[string]" ([StringComparer]::OrdinalIgnoreCase)
$DetectedSecretMap = @{}

# 並列読み込みを使う場合も順序は維持したいので、結果は一旦貯める
$results = New-Object System.Collections.Generic.List[psobject]

function Get-FileClassification([System.IO.FileInfo]$fileInfo) {
  $rel = Get-NormalizedPath (Get-RelativePath $rootFull $fileInfo.FullName)

  $hiddenDirRel = Get-HiddenAncestorRel $rel $HideDirNames

  $isHiddenFile = Test-MatchAnyPattern $fileInfo.Name $HideFilePatterns
  $isRedact = (Test-PathMatchesPattern $rel $RedactDirNames $RedactFilePatterns) -and -not (Test-NameIn $fileInfo.Name $AllowEnvNames)


  return [pscustomobject]@{
    Rel          = $rel
    HiddenDirRel = $hiddenDirRel
    IsHiddenFile = $isHiddenFile
    IsRedacted   = $isRedact
    SizeBytes    = $fileInfo.Length
    FullName     = $fileInfo.FullName
    Name         = $fileInfo.Name
  }
}

if ($ParallelRead -and $PSVersionTable.PSVersion.Major -ge 7) {
  Write-Host "[DEBUG] Mode: Parallel (PS7+)"
  # まず分類だけは直列で（軽い）。読み込みだけ並列
  $classified = @(
    foreach ($f in $allFiles) { Get-FileClassification $f }
  )


  $total = $classified.Count

  $readables = $classified | Where-Object {
    -not $_.HiddenDirRel -and -not $_.IsHiddenFile -and -not $_.IsRedacted -and $_.SizeBytes -le $maxBytes
  }

  $FindSensitive = ${function:Find-SensitiveContent}

  $readMap = $readables | ForEach-Object -Parallel {
    # パラレル側では $using: を使う
    $full = $_.FullName
    $rel = $_.Rel

    # バイナリ判定→テキスト読み込み
    $isBin = $false
    $fs = [System.IO.File]::Open($full, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite)
    try {
      $buf = New-Object byte[] $using:BinaryDetectionBufferSize
      $read = $fs.Read($buf, 0, $buf.Length)
      for ($i = 0; $i -lt $read; $i++) { if ($buf[$i] -eq 0) { $isBin = $true; break } }
    }
    finally { $fs.Dispose() }

    if ($isBin) {
      return [pscustomobject]@{ Rel = $rel; Kind = "Binary"; Content = $null }
    }

    $fs2 = [System.IO.File]::Open($full, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite)
    try {
      $reader = New-Object System.IO.StreamReader($fs2, [System.Text.Encoding]::UTF8, $true, 4096, $true)
      
      $isCsv = $rel.EndsWith(".csv", [StringComparison]::OrdinalIgnoreCase)
      $limit = if ($isCsv) { $using:CsvPreviewLines } else { 0 }
      $text = $null

      if ($limit -gt 0) {
        $acc = New-Object System.Collections.Generic.List[string]
        $max = $limit
        while ($max -gt 0 -and -not $reader.EndOfStream) {
          $line = $reader.ReadLine()
          if ($null -eq $line) { break }
          $acc.Add($line) | Out-Null
          $max--
        }
        if (-not $reader.EndOfStream) {
          $acc.Add("... (truncated first $limit lines)") | Out-Null
        }
        $text = ($acc -join [Environment]::NewLine)
      }
      else {
        $text = $reader.ReadToEnd()
      }

      $reader.Dispose()
      $det = @(& $using:FindSensitive $text)
      if ($det.Count -gt 0) {
        return [pscustomobject]@{ Rel = $rel; Kind = "Sensitive"; Detections = $det }
      }
      return [pscustomobject]@{ Rel = $rel; Kind = "Text"; Content = $text }
    }
    finally { $fs2.Dispose() }
  } -ThrottleLimit $ThrottleLimit

  # Rel -> read result
  $readDict = @{}
  foreach ($r in $readMap) { $readDict[$r.Rel] = $r }

  for ($i = 0; $i -lt $classified.Count; $i++) {
    $c = $classified[$i]
    if ($ShowProgress) {
      $pct = [int](($i + 1) * 100 / [Math]::Max(1, $total))
      Write-Progress -Activity "ファイル処理中" -Status "$($i+1)/$total" -PercentComplete $pct
    }

    # ディレクトリ単位非表示
    if ($c.HiddenDirRel) {
      if (-not $writtenHiddenDir.Contains($c.HiddenDirRel)) {
        $results.Add([pscustomobject]@{ Order = $i; Type = "HiddenDir"; Rel = $c.HiddenDirRel }) | Out-Null
        [void]$writtenHiddenDir.Add($c.HiddenDirRel)
      }
      continue
    }

    if ($c.IsHiddenFile) { $results.Add([pscustomobject]@{ Order = $i; Type = "HiddenFile"; Rel = $c.Rel }) | Out-Null; continue }
    if ($c.IsRedacted) { $results.Add([pscustomobject]@{ Order = $i; Type = "Redacted"; Rel = $c.Rel }) | Out-Null; continue }

    if ($c.SizeBytes -gt $maxBytes) { $results.Add([pscustomobject]@{ Order = $i; Type = "TooLarge"; Rel = $c.Rel; Size = $c.SizeBytes }) | Out-Null; continue }

    $rr = $readDict[$c.Rel]
    if ($null -eq $rr) {
      # 読み対象でない＝ここには来ないはずだが保険
      $results.Add([pscustomobject]@{ Order = $i; Type = "Skipped"; Rel = $c.Rel }) | Out-Null
      continue
    }

    if ($rr.Kind -eq "Binary") {
      $results.Add([pscustomobject]@{ Order = $i; Type = "Binary"; Rel = $c.Rel }) | Out-Null
      continue
    }

    if ($rr.Kind -eq "Sensitive") {
      $DetectedSecretMap[$c.Rel] = $rr.Detections
      $results.Add([pscustomobject]@{ Order = $i; Type = "Sensitive"; Rel = $c.Rel; Detections = $rr.Detections }) | Out-Null
      continue
    }

    $results.Add([pscustomobject]@{
        Order = $i; Type = "Text"; Rel = $c.Rel; FullName = $c.FullName; Name = $c.Name; Content = $rr.Content
      }) | Out-Null
  }

  if ($ShowProgress) { Write-Progress -Activity "ファイル処理中" -Completed }
}
else {
  Write-Host "[DEBUG] Mode: Serial (PS5.1 or requested)"
  # 直列版（読みやすさ優先）
  $total = $allFiles.Count
  for ($i = 0; $i -lt $allFiles.Count; $i++) {
    $fileInfo = $allFiles[$i]
    $c = Get-FileClassification $fileInfo

    if ($c.HiddenDirRel) {
      if (-not $writtenHiddenDir.Contains($c.HiddenDirRel)) {
        $results.Add([pscustomobject]@{ Order = $i; Type = "HiddenDir"; Rel = $c.HiddenDirRel }) | Out-Null
        [void]$writtenHiddenDir.Add($c.HiddenDirRel)
      }
      continue
    }

    if ($c.IsHiddenFile) { $results.Add([pscustomobject]@{ Order = $i; Type = "HiddenFile"; Rel = $c.Rel }) | Out-Null; continue }
    
    # ログ出力位置を変更：除外対象でない場合のみ表示
    if ($ShowProgress) {
      $pct = [int](($i + 1) * 100 / [Math]::Max(1, $total))
      Write-Progress -Activity "ファイル処理中" -Status "$($i+1)/$total" -PercentComplete $pct
    }
    Write-Host "[DEBUG] Processing ($($i+1)/$total): $($fileInfo.Name)"

    if ($c.IsRedacted) { $results.Add([pscustomobject]@{ Order = $i; Type = "Redacted"; Rel = $c.Rel }) | Out-Null; continue }

    if ($c.SizeBytes -gt $maxBytes) { $results.Add([pscustomobject]@{ Order = $i; Type = "TooLarge"; Rel = $c.Rel; Size = $c.SizeBytes }) | Out-Null; continue }

    if (Test-IsProbablyBinary $c.FullName) { $results.Add([pscustomobject]@{ Order = $i; Type = "Binary"; Rel = $c.Rel }) | Out-Null; continue }

    $limit = 0
    if ($c.Name.EndsWith(".csv", [StringComparison]::OrdinalIgnoreCase)) { $limit = $CsvPreviewLines }

    $text = Read-TextFileAutoEncoding $c.FullName $limit
    $detected = @(Find-SensitiveContent $text)
    if ($detected.Count -gt 0) {
      $DetectedSecretMap[$c.Rel] = $detected
      $results.Add([pscustomobject]@{ Order = $i; Type = "Sensitive"; Rel = $c.Rel; Detections = $detected }) | Out-Null
      continue
    }
    $results.Add([pscustomobject]@{
        Order = $i; Type = "Text"; Rel = $c.Rel; FullName = $c.FullName; Name = $c.Name; Content = $text
      }) | Out-Null
  }

  if ($ShowProgress) { Write-Progress -Activity "ファイル処理中" -Completed }
}

# ---------------------------
# Markdown 出力組み立て（順序維持）
# ---------------------------
$results = @($results.ToArray())
$tree = Get-TreeLines $rootFull $DetectedSecretMap

$sb = New-Object System.Text.StringBuilder

# 仕様ヘッダ
[void]$sb.AppendLine("===== BEGIN FILE: DUMP_META =====")
[void]$sb.AppendLine("file_tree=FILE_TREE")
[void]$sb.AppendLine("file_block=BEGIN/END")
[void]$sb.AppendLine('begin_pattern="===== BEGIN FILE: {path} | lang={lang} ====="')
[void]$sb.AppendLine('end_pattern="===== END FILE: {path} ====="')
[void]$sb.AppendLine('redaction_notice="Files may be omitted or redacted; see inline placeholders."')
[void]$sb.AppendLine("===== END FILE: DUMP_META =====")
[void]$sb.AppendLine("")

foreach ($l in $tree) { [void]$sb.AppendLine($l) }

foreach ($r in $results) {
  switch ($r.Type) {
    "HiddenDir" {
      [void]$sb.AppendLine("===== BEGIN FILE: $($r.Rel)/ | lang=redacted =====")
      [void]$sb.AppendLine("[REDACTED: Directory content hidden (existence only)]")
      [void]$sb.AppendLine("===== END FILE: $($r.Rel)/ =====")
      [void]$sb.AppendLine("")
    }
    "HiddenFile" {
      [void]$sb.AppendLine("===== BEGIN FILE: $($r.Rel) | lang=redacted =====")
      [void]$sb.AppendLine("[REDACTED: Hidden file (build artifact, binary, etc.)]")
      [void]$sb.AppendLine("===== END FILE: $($r.Rel) =====")
      [void]$sb.AppendLine("")
    }
    "Redacted" {
      [void]$sb.AppendLine("===== BEGIN FILE: $($r.Rel) | lang=redacted =====")
      [void]$sb.AppendLine("[REDACTED: Sensitive configuration/key]")
      [void]$sb.AppendLine("===== END FILE: $($r.Rel) =====")
      [void]$sb.AppendLine("")
    }
    "Sensitive" {
      $det = $(if ($r.Detections) { ($r.Detections -join ", ") } else { "Unknown" })
      [void]$sb.AppendLine("===== BEGIN FILE: $($r.Rel) | lang=redacted =====")
      [void]$sb.AppendLine("[REDACTED: Sensitive bits detected: $det]")
      [void]$sb.AppendLine("===== END FILE: $($r.Rel) =====")
      [void]$sb.AppendLine("")
    }
    "TooLarge" {
      [void]$sb.AppendLine("===== BEGIN FILE: $($r.Rel) | lang=redacted =====")
      [void]$sb.AppendLine("[REDACTED: File size $([Math]::Round($r.Size/1MB,2)) MB exceeds limit ($MaxFileSizeMB MB)]")
      [void]$sb.AppendLine("===== END FILE: $($r.Rel) =====")
      [void]$sb.AppendLine("")
    }
    "Binary" {
      [void]$sb.AppendLine("===== BEGIN FILE: $($r.Rel) | lang=redacted =====")
      [void]$sb.AppendLine("[REDACTED: Binary file]")
      [void]$sb.AppendLine("===== END FILE: $($r.Rel) =====")
      [void]$sb.AppendLine("")
    }
    "Text" {
      $ext = [System.IO.Path]::GetExtension($r.Name)
      $lang = Get-LangFromExtension $ext
      $lang = if ($lang) { $lang } else { "text" }
      
      [void]$sb.AppendLine("===== BEGIN FILE: $($r.Rel) | lang=$lang =====")
      [void]$sb.AppendLine(($r.Content).TrimEnd("`r", "`n"))
      [void]$sb.AppendLine("===== END FILE: $($r.Rel) =====")
      [void]$sb.AppendLine("")
    }
    default {
      [void]$sb.AppendLine("===== BEGIN FILE: $($r.Rel) | lang=redacted =====")
      [void]$sb.AppendLine("[REDACTED: Skipped]")
      [void]$sb.AppendLine("===== END FILE: $($r.Rel) =====")
      [void]$sb.AppendLine("")
    }
  }
}

# ---------------------------
# 出力
# ---------------------------
$dirOut = Split-Path -Parent $OutPath
if ($dirOut -and -not (Test-Path -LiteralPath $dirOut)) {
  New-Item -ItemType Directory -Path $dirOut | Out-Null
}
[System.IO.File]::WriteAllText($OutPath, $sb.ToString(), [System.Text.Encoding]::UTF8)

if ($DetectedSecretMap.Count -gt 0) {
  Write-Host "Sensitive content detected in:"
  foreach ($path in ($DetectedSecretMap.Keys | Sort-Object)) {
    $label = ($DetectedSecretMap[$path] -join ", ")
    Write-Host " - $path ($label)"
  }
}

Write-Host "Wrote: $OutPath"
===== END FILE: RepoDump.ps1 =====

===== BEGIN FILE: .git/ | lang=redacted =====
[REDACTED: Directory content hidden (existence only)]
===== END FILE: .git/ =====

===== BEGIN FILE: workspace/ | lang=redacted =====
[REDACTED: Directory content hidden (existence only)]
===== END FILE: workspace/ =====

===== BEGIN FILE: workspace.example/BatchDump.ps1 | lang=powershell =====
<#
.SYNOPSIS
BatchDump.ps1 - 複数のディレクトリをまとめてダンプするラッパースクリプト

.DESCRIPTION
workspace.json (または指定された設定ファイル) に定義されたターゲットリストに基づいて、
RepoDump.ps1 を順次実行し、Markdownファイルを一括生成します。

.EXAMPLE
.\BatchDump.ps1

.EXAMPLE
.\BatchDump.ps1 -ConfigFile "MyConfig.json" -OutDir ".\output"
#>

param(
    [string]$ConfigFile = "workspace.json",
    [string]$OutDir = ".",
    [string]$RepoDumpScript = "..\RepoDump.ps1",
    [switch]$Force
)

$ErrorActionPreference = "Stop"
Set-StrictMode -Version Latest

# -------------------------------------------------------------
# ユーティリティ関数
# -------------------------------------------------------------
function Write-Log([string]$msg, [string]$color = "White") {
    $ts = Get-Date -Format "HH:mm:ss"
    Write-Host "[$ts] $msg" -ForegroundColor $color
}

# -------------------------------------------------------------
# 準備
# -------------------------------------------------------------
$scriptRoot = $PSScriptRoot
if (-not $scriptRoot) { $scriptRoot = (Get-Location).Path }

# 親ディレクトリ（プロジェクトルート）
$projectRoot = Split-Path -Parent $scriptRoot

$configPath = Resolve-Path -Path $ConfigFile -ErrorAction SilentlyContinue
if (-not $configPath) {
    Write-Error "Configuration file not found: $ConfigFile"
    exit 1
}

$repoDumpPath = Resolve-Path -Path $RepoDumpScript -ErrorAction SilentlyContinue
if (-not $repoDumpPath) {
    Write-Error "RepoDump script not found: $RepoDumpScript"
    exit 1
}

# 出力ディレクトリ作成
if (-not (Test-Path -LiteralPath $OutDir)) {
    New-Item -ItemType Directory -Path $OutDir -Force | Out-Null
    Write-Log "Created output directory: $OutDir" "Cyan"
}

# 設定読み込み
try {
    $json = Get-Content -LiteralPath $configPath -Raw -Encoding UTF8 | ConvertFrom-Json
    $targets = $json.Targets
}
catch {
    Write-Error "Failed to parse JSON config: $_"
    exit 1
}

if (-not $targets) {
    Write-Warning "No targets found in configuration."
    exit 0
}

Write-Log "Loaded configuration from $($configPath.Path)" "Green"
Write-Log "Found $($targets.Count) targets." "Green"

# -------------------------------------------------------------
# メイン処理
# -------------------------------------------------------------
$timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
$successCount = 0
$failCount = 0

foreach ($t in $targets) {
    $name = $t.Name
    $relPath = $t.Path

    if ([string]::IsNullOrWhiteSpace($name) -or [string]::IsNullOrWhiteSpace($relPath)) {
        Write-Warning "Skipping invalid target entry: Name='$name', Path='$relPath'"
        continue
    }

    # パス解決（プロジェクトルート基準）
    $targetFullPath = $null
    if (Split-Path $relPath -IsAbsolute) {
        $targetFullPath = $relPath
    }
    else {
        $targetFullPath = Join-Path $projectRoot $relPath
    }
    
    if (-not (Test-Path -LiteralPath $targetFullPath)) {
        Write-Warning "Target path not found: $targetFullPath (Name: $name). Skipping."
        $failCount++
        continue
    }
    $targetFullPath = (Resolve-Path -LiteralPath $targetFullPath).Path

    # 出力ファイル名
    $outFile = Join-Path $OutDir "${timestamp}_${name}.md"
    if (-not (Split-Path $outFile -IsAbsolute)) {
        $outFile = Join-Path $scriptRoot $outFile
    }

    Write-Log "Processing target: [$name] -> $relPath" "Cyan"
    
    try {
        # RepoDump.ps1 呼び出し
        $params = @{
            RootPath     = $targetFullPath
            OutPath      = $outFile
            UseGitignore = $true
        }

        # サブプロセスで実行
        & $repoDumpPath.Path @params | Out-Null

        if ($LASTEXITCODE -eq 0 -and (Test-Path $outFile)) {
            Write-Log "  -> Success: $outFile" "Gray"
            $successCount++
        }
        else {
            Write-Log "  -> Failed (ExitCode: $LASTEXITCODE)" "Red"
            $failCount++
        }
    }
    catch {
        Write-Log "  -> Error: $_" "Red"
        $failCount++
    }
}

# -------------------------------------------------------------
# 完了
# -------------------------------------------------------------
Write-Host ""
Write-Log "Batch dump completed." "Green"
Write-Log "Success: $successCount, Failed: $failCount" $(if ($failCount -gt 0) { "Red" }else { "Green" })
===== END FILE: workspace.example/BatchDump.ps1 =====

===== BEGIN FILE: workspace.example/workspace.json | lang=json =====
{
  "Targets": [
    {
      "Name": "This Repository",
      "Path": "."
    },
    {
      "Name": "workspace.example",
      "Path": "workspace.example"
    }
  ]
}
===== END FILE: workspace.example/workspace.json =====
===== END FILE: 20251216_023753_This Repository.md =====

===== BEGIN FILE: BatchDump.ps1 | lang=powershell =====
<#
.SYNOPSIS
BatchDump.ps1 - 複数のディレクトリをまとめてダンプするラッパースクリプト

.DESCRIPTION
workspace.json (または指定された設定ファイル) に定義されたターゲットリストに基づいて、
RepoDump.ps1 を順次実行し、Markdownファイルを一括生成します。

.EXAMPLE
.\BatchDump.ps1

.EXAMPLE
.\BatchDump.ps1 -ConfigFile "MyConfig.json" -OutDir ".\output"
#>

param(
    [string]$ConfigFile = "workspace.json",
    [string]$OutDir = ".",
    [string]$RepoDumpScript = "..\RepoDump.ps1",
    [switch]$Force
)

$ErrorActionPreference = "Stop"
Set-StrictMode -Version Latest

# -------------------------------------------------------------
# ユーティリティ関数
# -------------------------------------------------------------
function Write-Log([string]$msg, [string]$color = "White") {
    $ts = Get-Date -Format "HH:mm:ss"
    Write-Host "[$ts] $msg" -ForegroundColor $color
}

# -------------------------------------------------------------
# 準備
# -------------------------------------------------------------
$scriptRoot = $PSScriptRoot
if (-not $scriptRoot) { $scriptRoot = (Get-Location).Path }

# 親ディレクトリ（プロジェクトルート）
$projectRoot = Split-Path -Parent $scriptRoot

$configPath = Resolve-Path -Path $ConfigFile -ErrorAction SilentlyContinue
if (-not $configPath) {
    Write-Error "Configuration file not found: $ConfigFile"
    exit 1
}

$repoDumpPath = Resolve-Path -Path $RepoDumpScript -ErrorAction SilentlyContinue
if (-not $repoDumpPath) {
    Write-Error "RepoDump script not found: $RepoDumpScript"
    exit 1
}

# 出力ディレクトリ作成
if (-not (Test-Path -LiteralPath $OutDir)) {
    New-Item -ItemType Directory -Path $OutDir -Force | Out-Null
    Write-Log "Created output directory: $OutDir" "Cyan"
}

# 設定読み込み
try {
    $json = Get-Content -LiteralPath $configPath -Raw -Encoding UTF8 | ConvertFrom-Json
    $targets = $json.Targets
}
catch {
    Write-Error "Failed to parse JSON config: $_"
    exit 1
}

if (-not $targets) {
    Write-Warning "No targets found in configuration."
    exit 0
}

Write-Log "Loaded configuration from $($configPath.Path)" "Green"
Write-Log "Found $($targets.Count) targets." "Green"

# -------------------------------------------------------------
# メイン処理
# -------------------------------------------------------------
$timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
$successCount = 0
$failCount = 0

foreach ($t in $targets) {
    $name = $t.Name
    $relPath = $t.Path

    if ([string]::IsNullOrWhiteSpace($name) -or [string]::IsNullOrWhiteSpace($relPath)) {
        Write-Warning "Skipping invalid target entry: Name='$name', Path='$relPath'"
        continue
    }

    # パス解決（プロジェクトルート基準）
    $targetFullPath = $null
    if (Split-Path $relPath -IsAbsolute) {
        $targetFullPath = $relPath
    }
    else {
        $targetFullPath = Join-Path $projectRoot $relPath
    }
    
    if (-not (Test-Path -LiteralPath $targetFullPath)) {
        Write-Warning "Target path not found: $targetFullPath (Name: $name). Skipping."
        $failCount++
        continue
    }
    $targetFullPath = (Resolve-Path -LiteralPath $targetFullPath).Path

    # 出力ファイル名
    $outFile = Join-Path $OutDir "${timestamp}_${name}.md"
    if (-not (Split-Path $outFile -IsAbsolute)) {
        $outFile = Join-Path $scriptRoot $outFile
    }

    Write-Log "Processing target: [$name] -> $relPath" "Cyan"
    
    try {
        # RepoDump.ps1 呼び出し
        $params = @{
            RootPath     = $targetFullPath
            OutPath      = $outFile
            UseGitignore = $true
        }

        # サブプロセスで実行
        & $repoDumpPath.Path @params | Out-Null

        if ($LASTEXITCODE -eq 0 -and (Test-Path $outFile)) {
            Write-Log "  -> Success: $outFile" "Gray"
            $successCount++
        }
        else {
            Write-Log "  -> Failed (ExitCode: $LASTEXITCODE)" "Red"
            $failCount++
        }
    }
    catch {
        Write-Log "  -> Error: $_" "Red"
        $failCount++
    }
}

# -------------------------------------------------------------
# 完了
# -------------------------------------------------------------
Write-Host ""
Write-Log "Batch dump completed." "Green"
Write-Log "Success: $successCount, Failed: $failCount" $(if ($failCount -gt 0) { "Red" }else { "Green" })
===== END FILE: BatchDump.ps1 =====

===== BEGIN FILE: workspace.json | lang=json =====
{
  "Targets": [
    {
      "Name": "This Repository",
      "Path": "."
    },
    {
      "Name": "workspace.example",
      "Path": "workspace.example"
    }
  ]
}
===== END FILE: workspace.json =====

